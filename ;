#include "grid.h"

#include "tile.h"
#include <algorithm>

Grid::Grid() :
    Actor(),
    selectedTile(nullptr)
{
    tiles.resize(NB_ROWS);
    for (size_t i = 0; i < tiles.size(); i ++) {
        tiles[i].resize(NB_COLS);
    }

    // create tiles
    for (size_t i = 0; i < NB_COLS; i ++) {
        for (size_t j = 0; j < NB_ROWS; j ++) {
            tiles[i][j] = new Tile();
            tiles[i][j] -> setPosition(Vector2(TILESIZE / 2.f + j * TILESIZE, START_Y + i * TILESIZE));
            if (i >= NB_ROWS / 2 - 1 && i <= NB_ROWS / 2 + 1 && j >= NB_COLS / 2 - 1 && j <= NB_COLS / 2 + 1) {
                tiles[i][j] -> setTileState(Tile::TileState::Obstacle);
            } else {
                tiles[i][j] -> setTileState(Tile::TileState::Default);
            }
        }
    }

    // fill adjacent tiles
    for (size_t i = 0; i < NB_ROWS; i ++) {
        for (size_t j = 0; j < NB_COLS; j ++) {
            if (i > 0) {
                tiles[i][j] -> adjacentTiles.push_back(tiles[i - 1][j])
            }
        }
    }


    getStartTile().setTileState(Tile::TileState::Start);
    getEndTile().setTileState(Tile::TileState::Base);
}

void Grid::processClick(int x, int y) {
    y -= static_cast<int>(START_Y - TILESIZE / 2);
    if (y >= 0) {
        x /= static_cast<int>(TILESIZE);
        y /= static_cast<int>(TILESIZE);
        if (x >= 0 && x < static_cast<int>(NB_COLS) && y >= 0 && y < static_cast<int>(NB_ROWS)) {
            selectTile(y, x);
        }
    }
}

Tile& Grid::getStartTile() {
    return *tiles[3][0];
}

Tile& Grid::getEndTile() {
    return *tiles[3][15];
}
